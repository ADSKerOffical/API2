local Api = {}
Api.Number = {}
Api.String = {}
Api.Players = {}
Api.Chat = {}
Api.Sound = {}
Api.Client = {}
Api.Color = {}
Api.Table = {}
Api.Variable = {}

function Api.Number:Range(num, min, max)
  if not tonumber(num) or not tonumber(min) or not tonumber(max) then
    error("Api.Number:Range requires numeric arguments")
  end
    if min > max then
        error("Api.Number:Range: min must be less or equal to max")
    end
  return num >= min and num <= max
end

function Api.Number:IsEven(number)
  if type(number) == "number" then
    return number % 2 == 0
  else
    return nil
  end
end

function Api.Number:IsNegative(number)
    if type(number) == "number" then
        return number < 0
    else
        return nil
    end
end

function Api.Number:IsInteger(number)
  if type(number) ~= "number" then
     return nil
   end
  return number == math.floor(number)
end

function Api.String:Length(str)
  if type(str) ~= "string" then
   return nil
  end
   return #str
end

function Api.String:HasNumber(str)
  if type(str) ~= "string" then
    return nil
  end
   return string.find(str, "%d") ~= nil
end

function Api.String:HasSymbol(str, symbol)
  if type(str) ~= "string" or type(symbol) ~= "string" then
   return nil
  end
   return string.find(str, symbol) ~= nil
end

function Api.String:RandomString(num)
  if type(num) ~= "number" then
   return nil
  end
 local array = {}
 for i = 1, num do
  array[i] = string.char(math.random(32, 126))
 end
 return table.concat(array)
end

function Api.Color:Color3ToHex(color)
   if typeof(color) ~= "Color3" then
    return nil
   end
  return string.upper(color:ToHex())
end

function Api.String:ToRich(str, size, color)
  if type(str) == nil or type(size) ~= "number" or typeof(color) ~= "Color3" then
 return "nas"
  end
local hexC = Api.Color:Color3ToHex(color)
   if type(hexC) ~= "string" or typeof(color) ~= "Color3" then
   return "nas"
    end
   local html = string.format('<p><font size="%d" color="%s">%s</font></p>', size, hexC, str)
    return html
end

function Api.Client:SimulateButton(key)
 if type(key) ~= "string" then return nil end
  game:GetService("VirtualInputManager"):SendKeyEvent(true, key , false , game)
end

function Api.Client:GetHwid()
  return gethwid() or game:GetService("RbxAnalyticsService"):GetClientId()
end

function Api.Color:ToRGB(Color)
  return {R = Color.R, G = Color.G, B = Color.B}
end

function Api.Color:FromRGB(Color)
  return Color3.fromRGB(Color.R, Color.G, Color.B)
end

function Api.Color:FromHex(hex)
        local r, g, b = string.match(hex, "^#?(%w%w)(%w%w)(%w%w)$")
        return Color3.fromRGB(tonumber(r, 16),
                tonumber(g, 16), tonumber(b, 16))
end

function Api.Color:RGBToHex(color)
        return string.format("#%02X%02X%02X", color.R * 0xFF,
                color.G * 0xFF, color.B * 0xFF)
end

function Api.Table:GetObjects(tbl, bool)
  if typeof(tbl) == "Instance" then
local tyy = {}
 for _, pu in ipairs(tbl:GetDescendants()) do
     if bool == true then
   table.insert(tyy, pu:GetFullName())
     else
   table.insert(tyy, pu)
     end
 end
  return tyy
    else
local tyy = {}
 for _, pu in ipairs(tbl) do
   table.insert(tyy, pu)
 end
 return tyy
  end
end

function Api.Table:Copy(tbl)
  if type(tbl) ~= "table" then
return "nat"
  end
  
  local taoi = {}
   for key, value in pairs(tbl) do
      taoi[key] = value
   end
    return taoi
end

function Api.Table:DeepCopy(tbl)
  local function deepcopy(orig)
            local copy = {}
            for k, v in pairs(orig) do
                if type(v) == "table" then
                    copy[k] = deepcopy(v)
                else
                    copy[k] = v
                end
            end
        return copy
        end
      return deepcopy(tbl)
end

function Api.Table:IsReadonly(tbl)
  if type(tbl) == "table" then
    if setreadonly and isreadonly then
return isreadonly(tbl)
    end
  end
end

function Api.Variable:IsNil(var)
  return var == nil
end

function Api.Variable:IsGlobal(var)
  return _G[var] ~= nil
end

function Api.Players:GetPlayerBadgeCount(player)
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
    local userId = player.UserId
    local allBadges = {}
    local cursor = nil

    repeat
        local url = string.format("https://badges.roproxy.com/v1/users/%d/badges?limit=100&sortOrder=Asc", userId)
        if cursor then
            url = url .. "&cursor=" .. cursor
        end

        local success, response = pcall(function()
            return game:HttpGetAsync(url)
        end)

        if not success then
            warn("Error during HTTP request: " .. tostring(response))
            return nil
        end

        local decoded
        local success2, response2 = pcall(function()
            decoded = HttpService:JSONDecode(response)
        end)

        if not success2 then
            warn("Error decoding JSON: " .. tostring(response2))
            return nil
        end

        if decoded and decoded.data then
            for _, badgeData in ipairs(decoded.data) do
                table.insert(allBadges, badgeData)
            end
            cursor = decoded.nextPageCursor
        else
            warn("Invalid JSON format or no data.")
            return nil
        end
    until not cursor

    if allBadges then
        return #allBadges
    end

    return 0
end

function Api.Players:GetPlayerBadgeCountFromId(userId)
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
    local allBadges = {}
    local cursor = nil

    repeat
        local url = string.format("https://badges.roproxy.com/v1/users/%d/badges?limit=100&sortOrder=Asc", userId)
        if cursor then
            url = url .. "&cursor=" .. cursor
        end

        local success, response = pcall(function()
            return game:HttpGetAsync(url)
        end)

        if not success then
            warn("Error during HTTP request: " .. tostring(response))
            return nil
        end

        local decoded
        local success2, response2 = pcall(function()
            decoded = HttpService:JSONDecode(response)
        end)

        if not success2 then
            warn("Error decoding JSON: " .. tostring(response2))
            return nil
        end

        if decoded and decoded.data then
            for _, badgeData in ipairs(decoded.data) do
                table.insert(allBadges, badgeData)
            end
            cursor = decoded.nextPageCursor
        else
            warn("Invalid JSON format or no data.")
            return nil
        end
    until not cursor

    if allBadges then
        return #allBadges
    end

    return 0
end

function Api.Players:GetPlayerFriendsCountFromId(userId)
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
    local allFriends = {}
    local cursor = nil

    repeat
        local url = string.format("https://friends.roblox.com/v1/users/%d/friends", userId)
        if cursor then
            url = url .. "&cursor=" .. cursor
        end

        local success, response = pcall(function()
            return game:HttpGetAsync(url)
        end)

        if not success then
            warn("Error during HTTP request: " .. tostring(response))
            return nil
        end

        local decoded
        local success2, response2 = pcall(function()
            decoded = HttpService:JSONDecode(response)
        end)

        if not success2 then
            warn("Error decoding JSON: " .. tostring(response2))
            return nil
        end

        if decoded and decoded.data then
            for _, friendData in ipairs(decoded.data) do
                table.insert(allFriends, friendData)
            end
            cursor = decoded.nextPageCursor
        else
            warn("Invalid JSON format or no data")
            return nil
        end

    until not cursor

    return allFriends
end

function Api.Players:GetPlayerByLowerName(playerName)
 for _, player in ipairs(game.Players:GetPlayers()) do
  if string.find(player.Name:lower(), playerName:lower()) then
   return player
  end
 end
 return nil
end

function Api.Players:GetPlayerNameByIdAsync(id)
 local endpoint = "https://users.roproxy.com/v1/users/"
 return game:GetService("HttpService"):JSONDecode(game:HttpGetAsync(endpoint .. id)).name
end

function Api.Players:GetUserGroupsAsync(userId)
local HttpService = game:GetService("HttpService")
    local endpoint = "https://groups.roproxy.com/v1/users/"
    local url = endpoint .. userId .. "/groups/roles"

    local response = nil
    local success, errorMessage = pcall(function()
       response = game:HttpGetAsync(url)
    end)
    if not success then
      warn("Error during HTTP request: " .. errorMessage)
      return nil, "HTTP request error: "..errorMessage
    end

    local decoded
    local success2, decodeError = pcall(function()
        decoded = HttpService:JSONDecode(response)
    end)

    if not success2 then
         warn("Error during decoding JSON: " .. decodeError)
        return nil, "JSON decoding error: " .. decodeError
    end

    return decoded, nil
end

return Api
